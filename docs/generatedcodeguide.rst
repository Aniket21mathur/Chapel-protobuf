=====================
Chapel Generated Code
=====================

This page describes exactly what Chapel code the protocol buffer compiler
generates for protocol definitions using ``proto3`` syntax. You should read
the `proto3 language guide`_ before reading this document.

Compiler Invocation
-------------------
The protocol buffer compiler produces Chapel output when invoked with the ``--chpl_out``
command-line flag. The parameter to the ``--chpl_out`` option is the directory where
you want the compiler to write your Chapel output. The compiler creates a single
source file for each ``.proto`` file input, having a '.chpl' extension.

Only ``proto3`` messages are supported by the ``Chapel`` code generator. Ensure
that each ``.proto`` file begins with a declaration of:

.. code-block:: proto

  syntax = "proto3";

Ouput module name
-----------------
The name of the ouput file/module will be same as the ``package`` name. If the
``package`` name is not specified the module takes the name of the proto
file with all non-aplhanumeric characters replaced by an ``underscore``.

For example a file called ``address.proto`` without the package specifier will
result in an ouput file called ``address.chpl`` with the generated code wrapped
in a module of the same name.(Full implementation is not shown here.)

.. code-block:: chpl
  ...
  module address {
    record messageName {
    ...
    }
  }

The same proto file with the a package declaration ``package myPackage;`` will
result in a file called ``myPackage.chpl``.

.. code-block:: chpl
  ...
  module myPackage {
    record messageName {
    ...
    }
  }

Messages
--------
Given a simple message declaration:

.. code-block:: proto
  
  message Foo {
    int32 num = 1;
  }
  
The protocol buffer compiler generates a record called ``Foo``, which have message
field initializers and serialization/parsing functions for wire-type encoding.

 .. code-block:: chpl
  
  record Foo {

    // Record fields will be generated corresponding to each proto message field.
    var num: int(32);
    
    // Used to store encoded byte stream of unknown fields encountered while parsing.
    // As per proto3 documentation, unknown fields should be preserved and appended
    // to the generated message byte stream.
    var unknownFieldStream: bytes = "";
    
    // User exposed method for serializing data to protobuf wire format.
    // This is a wrapper method to the actual method, it is used for making a
    // binary writing channel out of the channel given as an input by the user. 
    proc serialize(ch) throws { ... }
    
    // Contains the actual implementation for serializing data. Calls the
    // append functions of the user support library. It appends the `unknownFieldStream`
    // at the end of the message.
    proc _serialize(binCh) throws { ... }
    
    // User exposed method for parsing data from protobuf wire format.
    // This is a wrapper method to the actual method, it is used for making a
    // binary reading channel out of the channel given as an input by the user. 
    proc deserialize(ch) throws { ... }
    
    // Contains the actual implementation for parsing data. Calls the consume
    // functions of the user support library. Appends unknown fields encountered
    // to the `unknownFieldStream` variable.
    proc _deserialize(binCh) throws { ... }
  
  }  

Nested Types
------------
A message can be declared inside another message. For example:

.. code-block:: proto

  message Foo {
    message Bar {
    
    }
  }

In this case, or if a message contains a nested enum, the compiler will generate
module level records/enums with name prefixed by the parent message name:

.. code-block:: chpl
  
  record Foo {
   ...
  }
  
  // Nested Types
  record Foo_Bar {
    ...
  }

.. note::
  Nested records or declaration of enums in records is currently not supported in
  Chapel. Once we have support for these, we can declare nested type in the parent
  record and thus avoiding the name prefix. 

Fields
------
The protocol buffer compiler generates a Chapel record field for each field defined
within a message. In case of Chapel, methods equivalent to `get` and `set` in other
languages are implicitly generated by the Chapel compiler.

Singular Fields
^^^^^^^^^^^^^^^
Every singular field generates a record field variable of an appropriate Chapel type. 
Fetching a value from a field which hasn't been explicitly set will return the 
default chapel value for that type. For example, a boolean field ``a`` will generate a
``bool`` type variable with default value to ``false``:

.. code-block:: chpl
  
  // Field "a"
  var a: bool;
  
Repeated Fields
^^^^^^^^^^^^^^^
Every repeated field generates a list of an appropriate Chapel type. 
Fetching a value from a field which hasn't been explicitly set will return an
empty list. For example, a repeated string field ``a`` will generate a list of
type ``string``:

.. code-block:: chpl
  
  // Field "a"
  var a: list(string);
 
Enumerations
------------
Given an enumeration definition like:

.. code-block:: proto
  
  enum Color {
    RED = 0;
    GREEN = 5;
    BLUE = 1234;
  }
  
The protocol buffer compiler will generate a Chapel enum type called Color with the 
same set of values. Nested enums also follow the same rules as nested messages explained
above.

The ``Color`` proto enum above would therefore become the following Chapel code:

.. code-block:: chpl
  
  enum Color {
    RED = 0,
    GREEN = 5,
    BLUE = 1234,
  }

  
.. _proto3 language guide: https://developers.google.com/protocol-buffers/docs/proto3
